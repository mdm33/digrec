var morphtag_fields = <%= PROIEL::MorphTag.fields.to_json %>;
var morphtag_field_sequence = <%= PROIEL::MorphTag::PRESENTATION_SEQUENCE.to_json %>;
var morphtag_field_positions = <%= Hash[*(PROIEL::MorphTag::fields.zip((0..PROIEL::MorphTag::fields.length).to_a).collect { |field, i| [field, i] }.flatten)].to_json %>;
var morphtag_default_pattern = <%= ('.' * PROIEL::MorphTag::fields.length).to_json %>;
var morphtags = <%= PROIEL::MorphTag.tag_space(@language).to_json %>;

// FIXME: Is there a simpler way of replacing a single
// character at a particular index in a string?
function stringReplaceChar(str, i, c) {
  var characters = str.toArray();
  characters[i] = c;
  return characters.join('');
}

// Updates a morphtag regexp pattern (containing "." for each field
// without a set value) with the value for a particular field.
function updateMorphtagPattern(pattern, field, value) {
  var position = morphtag_field_positions[field];

  return stringReplaceChar(pattern, position, value);
}

function extractLegalFieldValues(pattern, field) {
  var r = new RegExp("^" + pattern);
  var position = morphtag_field_positions[field];

  // This can be done a lot more elegantly, but in FF2 and other
  // browsers with slow JS implementations we need to do this
  // the old-fashioned, compact way to avoid too much laggin.
  var fields = new Array;

  for (var i = 0; i < morphtags.length; i++) {
    if (morphtags[i].match(r))
      fields.push(morphtags[i][position]);
  }

  return fields.uniq();
}

function extractFieldValues(field, full_morphtags) {

  return full_morphtags.collect(function(tag) { return tag[position]; }).uniq();
}

// Updates the option list for a field taking the given
// morphtag regexp pattern into account when computing the
// legal values.
function updateFieldOptions(field, pattern) {
  var element = $(field + '_field');
  var field_values = extractLegalFieldValues(pattern, field);

  var options = element.options;
  options.length = 0;

  field_values.each(function(value) {
    if (value != '-')  
      options[options.length] = new Option(getFieldValueSummary(field, value), value);
  });

  if (options.length == 0) {
    element.hide();
  } else {
    element.show();
  }
}

function fieldSelected(ev) {
  var element = Event.element(ev);
  var updated_field = element.id.sub('_field', '');

  cascadedFieldUpdate(updated_field, null);
}

function cascadedFieldUpdate(updated_field, new_field_values) {
  var pattern = morphtag_default_pattern;

  for (var i = 0; i < morphtag_field_sequence.length; i++) {
    var field = morphtag_field_sequence[i];
    var element = $(field + '_field');

    var field_selection = null;
    
    if (new_field_values)
      field_selection = new_field_values.get(field);

    if (!field_selection)
      field_selection = getSelectSelection(element);

    updateFieldOptions(field, pattern);

    // Ensure that noe "bad value" flags are left floating around.
    element.removeClassName('bad-field-value');
      
    if (field_selection) {
      for (var j = 0; j < element.options.length; j++) {
        if (element.options[j].value == field_selection) {
          element.options[j].selected = true;
          break;
        }
      }
    } else if (element.options.length > 0) {
      // No selection made but the field has to have a value.
      // Insert an empty option and highlight it as an error.
      element.addClassName('bad-field-value');
      var options = element.options;
      options[options.length] = new Option('', '-');
      options[options.length - 1].selected = true;
    }

    var current_selection = getSelectSelection(element);

    if (current_selection)
      pattern = updateMorphtagPattern(pattern, field, current_selection);
  }
}

document.observe('dom:loaded', function() {
  morphtag_field_sequence.each(function(field) {
    $(field + '_field').observe('change', fieldSelected);
  });
});
