grammar MorphologyDescription
  rule expression
    chain /
    concatenation /
    xrule /
    replacement /
    subst /
    filter /
    xregular_expression /
    lexicon /
    guess /
    mapping /
    union /
    literal
  end

  rule chain
    "chain(" [\s]* left_side:expression [\s]* "," [\s]* right_side:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Chain.new(left_side.evaluate, right_side.evaluate)
      end
    }
  end

  rule concatenation
    "cons(" [\s]* left_side:expression [\s]* "," [\s]* right_side:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Cons.new(left_side.evaluate, right_side.evaluate)
      end
    }
  end

  rule xrule
    "rule(" [\s]* string:expression [\s]* "," [\s]* rule:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Rule.new(string.evaluate, rule.evaluate)
      end
    }
  end

  rule replacement
    "replacement(" [\s]* string:expression [\s]* "," [\s]* from:expression [\s]* "," [\s]* to:expression [\s]* "," [\s]* left_ctx:expression [\s]* "," [\s]* right_ctx:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Replacement.new(string.evaluate, from.evaluate, to.evaluate,
                                             left_ctx.evaluate, right_ctx.evaluate)
      end
    }
  end

  rule subst
    "subst(" [\s]* string:expression [\s]* "," [\s]* from:expression [\s]* "," [\s]* to:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Subst.new(string.evaluate, from.evaluate, to.evaluate)
      end
    }
  end

  rule filter
    "filter(" [\s]* string:expression [\s]* "," [\s]* rule:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Filter.new(string.evaluate, rule.evaluate)
      end
    }
  end

  rule xregular_expression
    "regexp(" [\s]* expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::RegularExpression.new(expression.evaluate)
      end
    }
  end

  rule lexicon
    "lexicon()" { def evaluate; ClassBasedMorphology::Lexicon.new; end }
  end

  rule guess
    "guess()" { def evaluate; ClassBasedMorphology::Guess.new; end }
  end

  rule mapping
    "mapping(" [\s]* upper_level:expression [\s]* "," [\s]* lower_level:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Mapping.new(upper_level.evaluate, lower_level.evaluate)
      end
    }  
  end

  rule union
    "union(" [\s]* left:expression [\s]* "," [\s]* right:expression [\s]* ")" {
      def evaluate
        ClassBasedMorphology::Union.new(left.evaluate, right.evaluate)
      end
    }
  end

  rule literal
    [\s]* single_literal [\s]* {
      def evaluate
        ClassBasedMorphology::Literal.new(single_literal.value)
      end
    } /
    "[" [\s]* literal_list [\s]* "]" {
      def evaluate
        ClassBasedMorphology::Literal.new(literal_list.value)
      end
    }
  end

  rule literal_list
    single_literal [\s]* "," [\s]* literal_list {
      def value
        single_literal.value + literal_list.value
      end 
    } /
    single_literal
  end

  rule single_literal
    "{" [\s]* set_literal_list [\s]* "}" { def value; [set_literal_list.value] end } /
    '"' [^"]* '"' { def value; [text_value.sub(/^"/, '').sub(/"$/, '')] end } /
    "nil" { def value; [nil] end }
  end

  rule set_literal_list
    single_set_literal [\s]* "," [\s]* set_literal_list {
      def value
        single_set_literal.value + set_literal_list.value
      end 
    } /
    single_set_literal
  end    

  rule single_set_literal
    [\w]+ { def value; Set.new(text_value) end } 
  end
end
